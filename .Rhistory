G ~ D,
Y ~ D + K,
K ~ A,
X ~ C + A,
D ~ X,
exposure = "X",
outcome = "Y",
coords = list(x = c(X = 0, F = 0, D = 1, G = 1, Y = 3, H = 3, A = 0.5, C = -0.5, K = 2),
y = c(X = 1, F = 0, D = 1, G = 0, Y = 1, H = 0, A = 2, C = 2, K = 2))
)
ggdag_status(datadag) + theme_dag()
adjustmentSets(datadag, type = "all") ## Mine were correct!
## Creating the DAG
scmdag <- dagify(
X ~ Z,
Y ~ X + Z,
exposure = "Z",
outcome = "Y",
coords = list(x = c(X = 0, Y = .5, Z = 1),
y = c(X = 0, Z = 0, Y = .5))
)
ggdag_status(scmdag) + theme_dag()
## Creating the DAG
scmdag <- dagify(
X ~ Z,
Y ~ X + Z,
exposure = "X",
outcome = "Y",
coords = list(x = c(X = 0, Y = .5, Z = 1),
y = c(X = 0, Z = 0, Y = .5))
)
ggdag_status(scmdag) + theme_dag()
n <- 1000
Z <- rnorm(n = n, mean = 0, sd = 1)
X <- 2*Z + rnorm(n = n, mean = 0, sd = 1)
Y <- X + 2*Z + rnorm(n = n, mean = 0, sd = 1)
summary(lm(Y ~ X + Z))
set.seed(3)
Z <- rnorm(n = n, mean = 0, sd = 1)
X <- 2*Z + rnorm(n = n, mean = 0, sd = 1)
Y <- X + 2*Z + rnorm(n = n, mean = 0, sd = 1)
summary(lm(Y ~ X + Z))
data <- as.data.frame(readRDS("data_cd_ex1.RDS"))
library(ppcor)
## Marginal densities
cor.test(data$X1, data$X2)
cor.test(data$X1, data$X3)
cor.test(data$X1, data$X4)
cor.test(data$X2, data$X3)
cor.test(data$X2, data$X4)
cor.test(data$X3, data$X4)
pcor.test(data$X1, data$X2, data$X3)
pcor.test(data$X1, data$X2, data$X4)
pcor.test(data$X1, data$X3, data$X2)
pcor.test(data$X1, data$X3, data$X4)
pcor.test(data$X1, data$X4, data$X2)
pcor.test(data$X1, data$X4, data$X3)
pcor.test(data$X2, data$X3, data$X1) ## INDEPENDENT
pcor.test(data$X2, data$X3, data$X1) ## INDEPENDENT
pcor.test(data$X1, data$X4, data$X3)
pcor.test(data$X2, data$X3, data$X4)
pcor.test(data$X2, data$X4, data$X1)
pcor.test(data$X2, data$X4, data$X3)
pcor.test(data$X3, data$X4, data$X1)
pcor.test(data$X3, data$X4, data$X2)
pcor(data)
pcor(data)
alpha <- .05
cor.test(data,r[1], data[r[2]])$p.value
marg_p_values <- apply(marginal_strinig, 1, function(r){
cor.test(data,r[1], data[r[2]])$p.value
})
marg_p_values <- apply(marginal_string, 1, function(r){
cor.test(data,r[1], data[r[2]])$p.value
})
print(marginal_string)
marg_p_values <- apply(data, 1, function(r){
cor.test(data,r[1], data[r[2]])$p.value
})
pcor(data)
## Skeleton of the DAG:
adj_full <- matrix(1,4,4)
diag(adj_full) <- 0
# make the layout custom (optional)
layout = matrix(c(0,1,-1,0,1,0,0,-1),4,2,byrow = T)
# Make the ``full'' graph
qgraph(adj_full, labels = names, layout = layout, directed = FALSE, title = "Full Undirected Graph", title.cex = 1.25, vsize = 15)
adj_full <- matrix(1,4,4)
diag(adj_full) <- 0
# make the layout custom (optional)
layout = matrix(c(0,1,-1,0,1,0,0,-1),4,2,byrow = T)
# Make the ``full'' graph
qgraph(adj_full, labels = names, layout = layout, directed = FALSE, title = "Full Undirected Graph", title.cex = 1.25, vsize = 15)
# Remove the edges between X2 - X3 and X1- x4
adj_full <- matrix(1,4,4)
diag(adj_full) <- 0
adj <- adj_full
adj[2,3] <- adj[3,2] <- 0
adj[1,4] <- adj[4,1] <- 0
# make the layout custom (optional)
layout = matrix(c(0,1,-1,0,1,0,0,-1),4,2,byrow = T)
par(mfrow=c(1,2))
qgraph(adj_full, labels = names, layout = layout, directed = FALSE, title = "Full Undirected Graph", title.cex = 1.25, vsize = 15)
qgraph(adj, labels = names, layout = layout, directed = FALSE, title = "Estimated Skeleton", title.cex = 1.25, vsize = 15)
cpdag <- adj
cpdag[4,2] <- 0 # we know that this arrow goes X2 -> X4
cpdag[4,3] <- 0 # we know the direction is X3 -> X4
# extra touch - making a matrix that indicates we have a mix of directed (true) and undirected (false) edges
cptf <- matrix(FALSE, 4,4)
cptf[2,4] <- cptf[3,4] <- TRUE
par(mfrow = c(1,1))
qgraph(cpdag, labels = names, layout = layout, directed = cptf, title = "Estimated CPDAG", title.cex = 1.25, asize = 8, vsize = 15)
cpdag <- adj
cpdag[4,2] <- 0 # we know that this arrow goes X2 -> X4
cpdag[4,3] <- 0 # we know the direction is X3 -> X4
# extra touch - making a matrix that indicates we have a mix of directed (true) and undirected (false) edges
cptf <- matrix(FALSE, 4,4)
cptf[2,4] <- cptf[3,4] <- TRUE
par(mfrow = c(1,1))
qgraph(cpdag, labels = names, layout = layout, directed = cptf, title = "Estimated CPDAG", title.cex = 1.25, asize = 8, vsize = 15)
cpdag <- adj
cpdag[4,2] <- 0 # we know that this arrow goes X2 -> X4
cpdag[4,3] <- 0 # we know the direction is X3 -> X4
# extra touch - making a matrix that indicates we have a mix of directed (true) and undirected (false) edges
cptf <- matrix(FALSE, 4,4)
cptf[2,4] <- cptf[3,4] <- TRUE
par(mfrow = c(1,1))
qgraph(cpdag, labels = names, layout = layout, directed = cptf, title = "Estimated CPDAG", title.cex = 1.25, asize = 8, vsize = 15)
dag1 <- matrix(c(
0  ,  0  ,  1  ,  0,
1  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0
), 4, 4, byrow = T)
dag2 <- matrix(c(
0  ,  1  ,  0  ,  0,
0  ,  0  ,  0  ,  1,
1  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0
), 4, 4, byrow = T)
dag3 <- matrix(c(
0  ,  1  ,  1  ,  0,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0
), 4, 4, byrow = T)
par(mfrow = c(1,3))
qgraph(dag1, labels = names, layout = layout, directed = TRUE, asize = 8, vsize = 15)
qgraph(dag2, labels = names, layout = layout, directed = TRUE, title = "Estimated Markov Equiv. Class", title.cex = 1.25, asize = 8, vsize = 15)
qgraph(dag3, labels = names, layout = layout, directed = TRUE, asize = 8, vsize = 15)
dag1 <- matrix(c(
0  ,  0  ,  1  ,  0,
1  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0), 4, 4, byrow = T)
dag2 <- matrix(c(
0  ,  1  ,  0  ,  0,
0  ,  0  ,  0  ,  1,
1  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0), 4, 4, byrow = T)
dag3 <- matrix(c(
0  ,  1  ,  1  ,  0,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  1,
0  ,  0  ,  0  ,  0), 4, 4, byrow = T)
par(mfrow = c(1,3))
qgraph(dag1, labels = names, layout = layout, directed = TRUE, asize = 8, vsize = 15)
qgraph(dag2, labels = names, layout = layout, directed = TRUE, title = "Estimated Markov Equiv. Class", title.cex = 1.25, asize = 8, vsize = 15)
qgraph(dag3, labels = names, layout = layout, directed = TRUE, asize = 8, vsize = 15)
library(pcalg)
suffStat <- list(C = cor(data), n = nrow(data))
pc_fit1 <- pc(suffStat = suffStat, indepTest = gaussCItest,
p = ncol(data), alpha = 0.01)
# This is the default plotting method for pcalg - uses Rgraphviz
plot(pc_fit1, main = "Inferred CPDAG using pcalg")
# Extract the adjacency matrix of the cpdag from pc_fit1
cpdag_mat <- as(pc_fit1,"matrix")
# Each row is a DAG adjacency matrix in vector form (by rows)
res1 <- pdag2allDags(cpdag_mat)
# We can get the adjacency matrix of an individual DAG using
res1_dags <- list()
for(i in 1:nrow(res1$dags)){
res1_dags[[i]] <- t(matrix(res1$dags[i,],4,4,byrow = TRUE))
}
# We can plot each of these just as we did above
par(mfrow = c(1,3))
for(i in 1:3){
qgraph(res1_dags[[i]], labels = names, layout = layout, directed = TRUE, asize = 8, vsize = 15)
}
ida(1,4,cov(data), pc_fit1@graph, verbose = TRUE)
library(tableone)
library(MatchIt)
library(survey)
df <- read.table("SchaferKangData.dat", header = TRUE)
str(df)
df$BLACK <- as.factor(df$BLACK)
df$NBHISP <- as.factor(df$NBHISP)
df$DIET <- as.factor(df$DIET)
rm(list=ls())
library(tableone)
library(MatchIt)
library(survey)
df <- read.table("SchaferKangData.dat", header = TRUE)
str(df)
df$BLACK <- as.factor(df$BLACK)
df$NBHISP <- as.factor(df$NBHISP)
df$DIET <- as.factor(df$DIET)
t.test(DISTR.2 ~ DIET , data = df)
df1 <- df[ which(df$DIET == 1), ]
df0 <- df[ which(df$DIET == 0), ]
(mean(df1$DISTR.1) - mean(df0$DISTR.1))/(sqrt( (var(df1$DISTR.1)+var(df0$DISTR.1))/2 ))
df1 <- df[ which(df$DIET == 1), ]
df0 <- df[ which(df$DIET == 0), ]
(mean(df1$DISTR.1) - mean(df0$DISTR.1))/(sqrt( (var(df1$DISTR.1)+var(df0$DISTR.1))/2 ))
table1 <- CreateTableOne(vars=c("DISTR.1","BLACK", "NBHISP", "GRADE",
"SLFHLTH", "SLFWGHT", "WORKHARD", "GOODQUAL",
"PHYSFIT", "PROUD", "LIKESLF", "ACCEPTED",
"FEELLOVD"), strata="DIET", data=df,
test=FALSE)
print(table1, smd = TRUE)
summary(glm(DISTR.2 ~ DIET + DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df))
## First, divide the data set into treated vs non treated
df0 <- subset(df, DIET == 0)
df1 <- subset(df, DIET == 1)
## Then get predicted values for distr.2 for both groups
M3.0 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df0)
M3.1 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df1)
# Obtain a prediction for the outcome using all the cases, based on
# the parameter estimates obtained above and saved in M3.1:
M3.est.Y1 <- predict(M3.1, newdata = df)
# Do the same, but now with the parameters saved in M3.0:
M3.est.Y0 <- predict(M3.0, newdata = df)
## Finally, estimate the average causal effect with a paired t.test
t.test(M3.est.Y0, M3.est.Y1, paired = TRUE, alternative = "two.sided")
## OPTIONAL --------------------------------------------------------------------
## Using the observed values where available
# Take the predicted potential outcome for X=0
# and only for those for whom we observed X=0
# do we overwrite the predicted potential outcome
M3b.Y0 <- M3.est.Y0
M3b.Y0[df$DIET==0] <- df$DISTR.2[df$DIET==0]
# Do the same for the predicted potential outcome for X=1
M3b.Y1 <- M3.est.Y1
M3b.Y1[df$DIET==1] <- df$DISTR.2[df$DIET==1]
# Now do the t-test with these (observed and predicted) potential outcomes:
t.test(M3b.Y0, M3b.Y1, paired = TRUE, alternative = "two.sided")
# Run the logistic regression analysis
logreg <- glm(DIET ~ DISTR.1 + as.factor(BLACK) + as.factor(NBHISP)
+ GRADE + SLFHLTH + SLFWGHT + WORKHARD + GOODQUAL
+ PHYSFIT + PROUD + LIKESLF + ACCEPTED + FEELLOVD,
family = binomial(), data = df)
# Obtain a prediction of the probability of treatment (i.e., DIET=1)
ps <- predict(logreg, type = "response")
# Add this predicted probability to the datafile
df$ps <- as.numeric(ps)
# Look at the datafile
round(df[1:10,], 2)
# Run the logistic regression analysis
logreg <- glm(DIET ~ DISTR.1 + as.factor(BLACK) + as.factor(NBHISP)
+ GRADE + SLFHLTH + SLFWGHT + WORKHARD + GOODQUAL
+ PHYSFIT + PROUD + LIKESLF + ACCEPTED + FEELLOVD,
family = binomial(), data = df)
# Obtain a prediction of the probability of treatment (i.e., DIET=1)
ps <- predict(logreg, type = "response")
# Add this predicted probability to the datafile
df$ps <- as.numeric(ps)
# Look at the datafile
round(df[1:10,], 2)
df1 <- df[ which(df$DIET == 1), ]
df0 <- df[ which(df$DIET == 0), ]
# Create histograms, then plot one and add the other:
hist0 <- hist(df0$ps, breaks=30, plot=FALSE)
hist1 <- hist(df1$ps, breaks=30, plot=FALSE)
plot( hist0, col=rgb(0,0,1,1/4), xlim=c(0,1),
xlab="Propensity score",
main="Histogram of propensity scores")
plot( hist1, col=rgb(1,0,0,1/4), xlim=c(0,1), add=T)
matchdat <- matchit(DIET ~ DISTR.1 + as.factor(BLACK) + as.factor(NBHISP)
+ GRADE + SLFHLTH + SLFWGHT + WORKHARD + GOODQUAL
+ PHYSFIT + PROUD + LIKESLF + ACCEPTED + FEELLOVD,
method = "nearest",  data = df)
matchdat
summary(matchdat)
plot(matchdat,type="jitter")
plot(matchdat,type="hist")
## First get the matched data set
df.match <- match.data(matchdat)
## Then t-test!
t.test2 <- t.test(DISTR.2 ~ DIET, df.match)
## And to get the SMD
t.test2$estimate[2] - t.test2$estimate[1]
Y <- df$DISTR.2
X <- df$DIET
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
Y <- df$DISTR.2
X <- df$DIET
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
## First create 5 strata that each hold 20% of observations
df$stratum <- cut(df$ps,
breaks=c(quantile(df$ps, probs=seq(0,1,0.2))),
labels=seq(1:5),
include.lowest=TRUE)
# We can also make a plot of these quantiles; this is based on
# using the same histrogram we had before, now adding vertical
# lines for where the breaks of the strat are.
plot( hist0, col=rgb(0,0,1,1/4), xlim=c(0,1),
xlab="Propensity score", main="Histogram of propensity scores \nwith quantile breaks")
plot( hist1, col=rgb(1,0,0,1/4), xlim=c(0,1), add=T)
br <- c(quantile(df$ps, probs=seq(0,1,0.2)))
abline(v=br[2],col="black",lwd=3)
abline(v=br[3],col="black",lwd=3)
abline(v=br[4],col="black",lwd=3)
abline(v=br[5],col="black",lwd=3)
results <- matrix(NA,5,1)
for (quintiles in c(1:5)) {
t.test3 <- t.test(DISTR.2 ~ DIET, data = df[which(df$stratum==quintiles),])
print(t.test3)
# Difference in means:
results[quintiles,1] <- t.test3$estimate[2] - t.test3$estimate[1]
}
mean(results)
Y <- df$DISTR.2
X <- df$DIET
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
Y <- as.numeric(df$DISTR.2)
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
Y <- as.numeric(df$DISTR.2)
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
Y <- as.numeric(df$DISTR.2)
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
library(tableone)
library(MatchIt)
library(survey)
df <- read.table("SchaferKangData.dat", header = TRUE)
str(df)
df$BLACK <- as.factor(df$BLACK)
df$NBHISP <- as.factor(df$NBHISP)
df$DIET <- as.factor(df$DIET)
t.test(DISTR.2 ~ DIET , data = df)
df1 <- df[ which(df$DIET == 1), ]
df0 <- df[ which(df$DIET == 0), ]
(mean(df1$DISTR.1) - mean(df0$DISTR.1))/(sqrt( (var(df1$DISTR.1)+var(df0$DISTR.1))/2 ))
table1 <- CreateTableOne(vars=c("DISTR.1","BLACK", "NBHISP", "GRADE",
"SLFHLTH", "SLFWGHT", "WORKHARD", "GOODQUAL",
"PHYSFIT", "PROUD", "LIKESLF", "ACCEPTED",
"FEELLOVD"), strata="DIET", data=df,
test=FALSE)
print(table1, smd = TRUE)
summary(glm(DISTR.2 ~ DIET + DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df))
## First, divide the data set into treated vs non treated
df0 <- subset(df, DIET == 0)
df1 <- subset(df, DIET == 1)
## Then get predicted values for distr.2 for both groups
M3.0 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df0)
M3.1 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df1)
# Obtain a prediction for the outcome using all the cases, based on
# the parameter estimates obtained above and saved in M3.1:
M3.est.Y1 <- predict(M3.1, newdata = df)
# Do the same, but now with the parameters saved in M3.0:
M3.est.Y0 <- predict(M3.0, newdata = df)
## Finally, estimate the average causal effect with a paired t.test
t.test(M3.est.Y0, M3.est.Y1, paired = TRUE, alternative = "two.sided")
## OPTIONAL --------------------------------------------------------------------
## Using the observed values where available
# Take the predicted potential outcome for X=0
# and only for those for whom we observed X=0
# do we overwrite the predicted potential outcome
M3b.Y0 <- M3.est.Y0
M3b.Y0[df$DIET==0] <- df$DISTR.2[df$DIET==0]
# Do the same for the predicted potential outcome for X=1
M3b.Y1 <- M3.est.Y1
M3b.Y1[df$DIET==1] <- df$DISTR.2[df$DIET==1]
# Now do the t-test with these (observed and predicted) potential outcomes:
t.test(M3b.Y0, M3b.Y1, paired = TRUE, alternative = "two.sided")
# Run the logistic regression analysis
logreg <- glm(DIET ~ DISTR.1 + as.factor(BLACK) + as.factor(NBHISP)
+ GRADE + SLFHLTH + SLFWGHT + WORKHARD + GOODQUAL
+ PHYSFIT + PROUD + LIKESLF + ACCEPTED + FEELLOVD,
family = binomial(), data = df)
# Obtain a prediction of the probability of treatment (i.e., DIET=1)
ps <- predict(logreg, type = "response")
# Add this predicted probability to the datafile
df$ps <- as.numeric(ps)
# Look at the datafile
round(df[1:10,], 2)
Y <- as.numeric(df$DISTR.2)
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
Y <- df$DISTR.2
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
library(tableone)
library(MatchIt)
library(survey)
df <- read.table("SchaferKangData.dat", header = TRUE)
str(df)
df$BLACK <- as.factor(df$BLACK)
df$NBHISP <- as.factor(df$NBHISP)
df$DIET <- as.factor(df$DIET)
t.test(DISTR.2 ~ DIET , data = df)
df1 <- df[ which(df$DIET == 1), ]
df0 <- df[ which(df$DIET == 0), ]
(mean(df1$DISTR.1) - mean(df0$DISTR.1))/(sqrt( (var(df1$DISTR.1)+var(df0$DISTR.1))/2 ))
table1 <- CreateTableOne(vars=c("DISTR.1","BLACK", "NBHISP", "GRADE",
"SLFHLTH", "SLFWGHT", "WORKHARD", "GOODQUAL",
"PHYSFIT", "PROUD", "LIKESLF", "ACCEPTED",
"FEELLOVD"), strata="DIET", data=df,
test=FALSE)
print(table1, smd = TRUE)
summary(glm(DISTR.2 ~ DIET + DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df))
## First, divide the data set into treated vs non treated
df0 <- subset(df, DIET == 0)
df1 <- subset(df, DIET == 1)
## Then get predicted values for distr.2 for both groups
M3.0 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df0)
M3.1 <- glm(DISTR.2 ~ DISTR.1 + BLACK + NBHISP + GRADE + SLFHLTH +
SLFWGHT + WORKHARD + GOODQUAL + PHYSFIT + PROUD +
LIKESLF + ACCEPTED + FEELLOVD, data = df1)
# Obtain a prediction for the outcome using all the cases, based on
# the parameter estimates obtained above and saved in M3.1:
M3.est.Y1 <- predict(M3.1, newdata = df)
# Do the same, but now with the parameters saved in M3.0:
M3.est.Y0 <- predict(M3.0, newdata = df)
## Finally, estimate the average causal effect with a paired t.test
t.test(M3.est.Y0, M3.est.Y1, paired = TRUE, alternative = "two.sided")
## OPTIONAL --------------------------------------------------------------------
## Using the observed values where available
# Take the predicted potential outcome for X=0
# and only for those for whom we observed X=0
# do we overwrite the predicted potential outcome
M3b.Y0 <- M3.est.Y0
M3b.Y0[df$DIET==0] <- df$DISTR.2[df$DIET==0]
# Do the same for the predicted potential outcome for X=1
M3b.Y1 <- M3.est.Y1
M3b.Y1[df$DIET==1] <- df$DISTR.2[df$DIET==1]
# Now do the t-test with these (observed and predicted) potential outcomes:
t.test(M3b.Y0, M3b.Y1, paired = TRUE, alternative = "two.sided")
# Run the logistic regression analysis
logreg <- glm(DIET ~ DISTR.1 + as.factor(BLACK) + as.factor(NBHISP)
+ GRADE + SLFHLTH + SLFWGHT + WORKHARD + GOODQUAL
+ PHYSFIT + PROUD + LIKESLF + ACCEPTED + FEELLOVD,
family = binomial(), data = df)
# Obtain a prediction of the probability of treatment (i.e., DIET=1)
ps <- predict(logreg, type = "response")
# Add this predicted probability to the datafile
df$ps <- as.numeric(ps)
# Look at the datafile
round(df[1:10,], 2)
Y <- df$DISTR.2
X <- as.numeric(df$DIET)
mu1hat <- sum( X*Y/ps ) / sum(X/ps)
mu0hat <- sum( (1-X)*Y/(1-ps) ) / sum((1-X)/(1-ps))
mu1hat - mu0hat
## First create 5 strata that each hold 20% of observations
df$stratum <- cut(df$ps,
breaks=c(quantile(df$ps, probs=seq(0,1,0.2))),
labels=seq(1:5),
include.lowest=TRUE)
# We can also make a plot of these quantiles; this is based on
# using the same histrogram we had before, now adding vertical
# lines for where the breaks of the strat are.
plot( hist0, col=rgb(0,0,1,1/4), xlim=c(0,1),
xlab="Propensity score", main="Histogram of propensity scores \nwith quantile breaks")
plot( hist1, col=rgb(1,0,0,1/4), xlim=c(0,1), add=T)
br <- c(quantile(df$ps, probs=seq(0,1,0.2)))
abline(v=br[2],col="black",lwd=3)
abline(v=br[3],col="black",lwd=3)
abline(v=br[4],col="black",lwd=3)
abline(v=br[5],col="black",lwd=3)
results <- matrix(NA,5,1)
for (quintiles in c(1:5)) {
t.test3 <- t.test(DISTR.2 ~ DIET, data = df[which(df$stratum==quintiles),])
print(t.test3)
# Difference in means:
results[quintiles,1] <- t.test3$estimate[2] - t.test3$estimate[1]
}
mean(results)
